/* 
  pgnhistogram_test.go
  Description: Unit test for histograms
  ----------------------------------------------------------------------------- 

  Started on  <Thu Jul  2 08:49:51 2015 Carlos Linares Lopez>
  Last update <miÃ©rcoles, 08 julio 2015 17:50:12 Carlos Linares Lopez (clinares)>
  -----------------------------------------------------------------------------

  $Id::                                                                      $
  $Date::                                                                    $
  $Revision::                                                                $
  -----------------------------------------------------------------------------

  Made by Carlos Linares Lopez
  Login   <clinares@atlas>
*/

package pgntools

import (
	"log"
	"math/rand"		// random number generator
	"strings"		// for splitting strings
	"testing"
	"time"			// for initializing the seed with current
				// nanosecs
)

// -- Globals

// Number of different keys to try in every level of a histogram
var NUMKEYS = 200

// Maximum number of samples per entry
var BOUND = 1000

// Maximum order to test
var ORDER = 3

// Separator character to use to distinguish different keys when they are given
// as a unique string
var SEP = "/"

// -- Functions

// return a slice with n random integers in the interval [0, bound). There is no
// guarantee that there are no duplicates even if n is very large
func randInts (n int, bound int) (result []int) {

	// First, create a new random number generator
	r  := rand.New(rand.NewSource(time.Now().UnixNano()))

	// now, generate the n integers and add them to the slice to return
	for i := 0 ; i< n ; i++ {

		result = append (result, r.Int () % bound)
	}

	// and return the slice of strings computed so far
	return
}

// return a slice with n permutations of the given string. There is no guarantee
// that the permutations will be unique but the larger the given string the more
// likely all permutations will be different
func randStrings (str []byte, n int) (result [][]byte) {

	// First, create a new random number generator
	r  := rand.New(rand.NewSource(time.Now().UnixNano()))

	// now, generate the n permutations
	for i := 0 ; i< n ; i++ {

		var nextStr []byte
		
		// create a new string according to the indexes of a random
		// permutation
		for _, value := range (r.Perm (len (str))) {
			nextStr = append (nextStr, str[value])
		}

		// and now add this string to the collection of strings to
		// return
		result = append (result, nextStr)
	}

	// and return the slice of strings computed so far
	return
}

// return a slice with n^depth permutations of the given string separated by a
// slash. There is no guarantee that the permutations will be unique but the
// larger the given string the more likely all permutations will be different
func randStringsMultiple (str []byte, n int, depth int) (result [][]byte) {

	// BASE CASE - depth = 0. Return a list with n empty lists
	if depth == 0 {

		for j := 0 ; j<n ; j++ {
			result = append (result, []byte (""))
		}
		
		return result
	}

	// GENERAL CASE - generate n different permutations of the given string
	iperms := randStrings (str, n)

	// If the current depth is strictly larger than 1, create n random
	// multiple strings for every random perm just generated (after
	// effectively decrementing the depth)
	if depth > 1 {
		
		for j := 0 ; j<n ; j++ {

			jperms := randStringsMultiple (str, n, depth-1)

			// compose every multiple permutation with every
			// permutation generated at this level. The strings in
			// jperm are preffixed with the j-th permutation in
			// iperms
			for k, kperm := range (jperms) {

				// create a new permutation concatenating the
				// k-th iperm and j-perm separated by the SEP
				// character
				result = append (result,
					append (append (iperms[k%n], []byte(SEP)...),
						kperm...))
			}
		}

		// and return the list generated so far
		return result
	}

	// at this point, return the permutations generated at this level
	return iperms
}

// creates a key usable by the histograms from a specification of random keys as
// generated by the services provided in this module. The input keys consist of
// a slice of byte arrays. The keys produced consist of a slice of strings. The
// separator character SEP is used to distinguish items in the output key.
func createIndex (inkey []byte) []string {

	// just split the input key into different strings that result from
	// using the separator character
	return strings.Split (string (inkey), SEP)
}

// -- Histograms

// Test the insertion and lookup operations in histograms of the given order.
//
// It generates up to NUMKEYS keys of the specified order and writes them into a
// histogram which is populated with NUMKEYS*factor random integer values. In
// case factor is larger than 1, then every key is used precisely factor times.
//
// It also verifies that the count items is correct both at the shallowest
//(root) and deepest (terminal) levels.
func testWithoutRepetition (order int, factor int, t *testing.T) {

	// the number of keys is given by the global variable NUMKEYS. Compute
	// now the number of observations which is NUMKEYS times factor
	nbobservations := NUMKEYS * factor
	
	// Create a number of (hopefully different) keys
	keys := randStringsMultiple ([]byte ("Roberto Dario Adriana"), NUMKEYS, order)

	// now, create a random number of samples
	samples := randInts (nbobservations, BOUND)

	// compute also the overall sum of all the random observations
	// generated. This is used later to verify that the accumluated number
	// of observations at level 0 is correct
	sum := 0
	for index := 0 ; index < nbobservations ; index++ {
		sum += samples [index]
	}

	// create a map that records the number of samples per key. This map
	// will be used to verify the output later on
	oracle := make (map[string]int)
	for index := 0 ; index < NUMKEYS ; index++ {

		// make sure this key has not been used before
		_, ok := oracle [string (keys[index])]; if ok {
			log.Fatal (" Duplicated keys")
		}
		
		oracle [string (keys[index])] = 0
		for iobservation := 0 ; iobservation < factor ; iobservation++ {
			oracle [string (keys[index])] += samples [index*factor + iobservation]
		}
	}

	// Now, update the histogram with these observations
	hist := NewHistogram ()
	for index := 0 ; index < NUMKEYS ; index++ {

		// write every observation into the histogram and verify that
		// the right value is returned
		for iobservation := 0 ; iobservation < factor ; iobservation++ {
			value := hist.Increment (createIndex (keys[index]),
				DataValue (samples[index*factor + iobservation]))
			if int(value) != samples[index*factor + iobservation] {
				t.Fatalf (" Increment did not return the right value (%v != %v)!",
					samples[index*factor + iobservation], value)
			}
		}
	}

	// Now, perform various lookups and ensure that the values stored are
	// correct. Note that the only lookups performed are those at the
	// shallowest and deepest levels

	// Level 0: shallowest lookup
	var key []string
	value := hist.Lookup (key)
	if int (value) != sum {
		t.Fatalf (" Root: Lookup did not return the right value (%v != %v)!",
			sum, value)
	}
	
	// Level n: shallowest lookup
	for index := 0 ; index < NUMKEYS ; index++ {

		// lookup the histogram and verify the value stored is the
		// expected one
		value := hist.Lookup (createIndex (keys[index]))
		if int (value) != oracle[string (keys[index])] {
			t.Fatalf (" Terminal: Lookup did not return the right value (%v != %v)!",
				oracle[string (keys[index])], value)
		}
	}
}

// Test the insertion and lookup operations in histograms with orders from 1 to
// ORDER. Additionally, different runs are performed with the same key been used
// from one to three times but different values.
func TestWithoutRepetition (t *testing.T) {

	log.Printf (" Testing with no repetitions\n")
	
	// for every different order
	for order := 1 ; order<=ORDER ; order++ {

		log.Printf (" Order: %v\n", order)
		testWithoutRepetition (order, 1, t)
	}

	log.Println ()
	log.Printf (" Testing with one repetition per key\n")
	
	// for every different order
	for order := 1 ; order<=ORDER ; order++ {

		log.Printf (" Order: %v\n", order)
		testWithoutRepetition (order, 2, t)
	}

	log.Println ()
	log.Printf (" Testing with two repetitions per key\n")
	
	// for every different order
	for order := 1 ; order<=ORDER ; order++ {

		log.Printf (" Order: %v\n", order)
		testWithoutRepetition (order, 3, t)
	}

	log.Println ()	
}

/* Local Variables: */
/* mode:go */
/* fill-column:80 */
/* End: */
